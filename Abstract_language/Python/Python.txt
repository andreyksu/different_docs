Python:
Атрибуты:
    nameModule.name где namе - атрибут модуля, nameModule - объект модуля.    
            Имена в модулях, яляются атрибутами модуля и образуеют одно пространство имен - глобальное пространство.
                Т.е. видимо когда загружается в интерпретатор данный модуль, создается объект модуля. Видимо что-то по аналогии с Java - при загрузке откомпилированного файла с расширением class - создается самой JVM объект Class.
    Под атрибутами понимают, все что идет после точки. Т.о. атрибуты модуля и глобальные имена имеют прямое соответствие, они совместно использую одно пространство имен.
    
    В отличии от классов, объект модуля может существовать в одном единственном экземпляре, по этой причине, необходимо использовать reload для обновления объекта модуля, что бы отобразить внесенные в модуль изменения.

    import sys
    sys.path.append("path") # определяет место, где искать импортируемые модули.

    Выполнение функции - вводит новую таблицу имен, используемую для локальных переменных. Все присвоения переменным в теле функции сохраняются в локальной таблице имен.
        Поиск переменных производится:
            В локальной таблице имен, затем в глобальной, в последнюю очередь в таблиц встроенных имен.        

Различают три пространства имен(области видимости).
    Встроенное     -     это то что относится к python (исключения итд)  и формируется при запуске интерпретатора, и существют на протяжении всего времени выполнения.
    Глобальное     -     это пространство имен модуля совпадающее с пространством атрибутов. Создается при считывании модуля, обычно существует до завершения работы интерперетатора.
    Локальное     -     пространство функции или класса. Для метода пространство создается при вызове метода и удаляется при выходе.
                    Все что вне функции или класса относится к глобальной области.    
        
Динамический поиск имен:
    1. В локальной области
    2. В голобальной области (если это внутри метода, что внутри класса то: область класса → область модуля)
    3. Во внешней области - область встроенных имен.

Инструкции выполняемые на верхнем уровне, т.е. читаемые из файла или интерактивно, рассматриваются как часть модуля __main__, имеющего собственное глобальное пространство имен.
    Встроенные имена также находятсяв модуле __builtin__


global - делает обявляемый атрибут/имя глобальным. Дефолтно если мы определяем в методе или классе имя оно является локальным, а с данным параметром мы делаем его глобальным.
del - удаляет имя из локального пространства имен. (Удаляет имя а не объект к которому привязано имя)
nonlocal - делает переменную доступной на уровень выше. Т.е. во вложенной функции, мы делаем переменную доступной в объемлющей функции.
    
Классы:
    Все атрибуты класса, включая поля данных являются открытыми, а все методы виртуальными.
        Виртуальные функции — специальный вид функций-членов класса. Виртуальная функция отличается об обычной функции тем, что для обычной функции связывание вызова функции с ее определением осуществляется на этапе компиляции. Для виртуальных функций это происходит во время выполнения программы.
            Виртуальная функция — это функция, которая определяется в базовом классе, а любой порожденный класс может ее переопределить. Виртуальная функция вызывается только через указатель или ссылку на базовый класс.

    Имя атрибутов классов перекрывают имена методов классов. По этому для избежания конфликтов нужно именовать по разному, или прийти к соглашению о приставках/суффиксах.

    - Есть понятие объект класса и объект экземпляра:
        ! Класс - играет роль фабрик экземпляров. Их атрибуты - данные и функции, наследуются всеми экземплярами, созданными от них.
        ! Экземпляр - конкретный экземпляр.
        ! Атрибуты классов ведут себя как статические атрибуты их экземпляров (то есть общие для всех экземпляров данного класса).
            Однако присвоить такому атрибуту новое значение Вы можете, только обратившись к нему как атрибуту того класса, в котором он определен (в противном случае Вы лишь создадите новый атрибут экземпляра с таким же именем).
        ! Атрибуты обычно присоединяются к классам путем присваивания внутри class, а не во вложенных def
        ! Атрибуты обычно присоединяются к экземплярам путём присванивания значинй специальному аргументу с именем self.
            !!! Нужно учитывать, что подобно простым переменным, атрибуты классов и экземпляров не объявляются заранее, а появляются, когда им впервые выполняется присваивание значений.
                Т.е. ниже по тексту до вызова setParam2 в экземпляре класса переменной param еще не существует.
        ! Так же как и инструкция def, инструкция class является выполняемой инструкцией. Когда она выполняется, она создает новый объект класса и присваивает его имени, указанному в заголовке инструкции class. Кроме того, как и инструкции def, инструкции class обычно выполняются при первом импортировании содержащих их файлов.
        
    - Инструкция def - является оператором присваивания. Он присваивает объект функции - имени фнукции.
    - Инструкция class - создает объект класса и присваивает ему имя (по сути создается объект и имени передается ссылка) отличие от Java в том что class в Java является объявлением а в Python инструкцией.
        ~ Как и в случае def выполняется при загрузке(при первом обращении к модулю).
        ~ Присваивания внутри инструкции class создает/формирует пространство имен атрибутов объекта класса.

    ???Самое важное, что методы в классах не обладают собственной областью видимостью(имен)
    - Вызов объекта класса (как метода - по сути в Java это называется конструктор) возвращает объект экземпляра.    
        ~ Какждый экземпляр приобретает свое собственное пространство имен.
        ~ Каждый экземпляр НАСЛЕДУЕТ атрибуты класса.
        ~ self создает или изменяет данные экземпляра а не класса (т.е. сохраняет значение в пространстве имен экземпляра на не класса).
            Т.е. изменять нужно переменные только через методы. Это будет изменять только значния экзмпляра, но не объекта класса. А все поля нужно делать приватные.
            class MyClass2:
                    param2 = 2
                    
                    def getParam2(self):
                            return self.param2

                    def setParam2(self, varr):
                            self.param = 1
                            self.param2 = varr

                    def setParam2(self, varr): #Здесь показывается, что метод имеет доступ к глобальным атрибутам, как обычная функция модуля. Так как он определен в классе, его глабальными атрибутами является определение классa.
                            param2 = varr

            В python нет перегрузки методов, но сделано для примера. Эти методы будут менять разные переменные. Т.е. первый set для экземпляров будет менять значение, а второй для класса.
            Это видно при получении через getParam и через получение по АТРИБУТУ класса.
            


Структура каталогов проекта Python

    Project/
    |-- bin/
    |   |-- project
    |
    |-- project/
    |   |-- test/
    |   |   |-- __init__.py
    |   |   |-- test_main.py
    |   |   
    |   |-- __init__.py
    |   |-- main.py
    |
    |-- setup.py
    |-- README


With...as
    with <Выражение>[ as <Переменная>]:
        <Блок, в котором перехватываем исключения>

    Вначале вычисляется <Выражение>, которое должно возвращать объект, поддерживающий протокол. Этот объект должен иметь два метода: __enter__() и __exit__(). Метод __enter__() вызывается после создания объекта. Значение, возвращаемое этим методом, присваивается переменной, указанной после ключевого слова as. Если переменная не указана, возвращаемое значение игнорируется. Формат метода __enter__():

    __enter__(self)

    Далее выполняется выражения внутри тела инструкции with. Если при выполнении возникло исключение, то управление передается методу __exit__(). Метод имеет следующий формат:

    __exit__(self, <Тип исключения>, <Значение>, <Объект traceback>)

    Значения, доступные через последние три параметра, полностью эквивалентны значения, возвращаемых функции exc_info() из модуля sys. Если исключение обработано, метод должен вернуть значение True, в противном случае - False. Если метод возвращает False, то исключение передается вышестоящему обработчику.

    Если при выполнении выражений, расположенных внутри тела инструкции with, исключение не возникло, то управление все равно передается методу __exit__(). В этом случае последние три параметра будут содержать значение None. 


Yield
    Yield – ключевое слово, которое используется вместо return.
        - Чтобы освоить yield, вы должны понимать, что когда вы вызываете функцию, код внутри тела функции не исполняется. Функция только возвращает объект-генератор.
        - С его помощью функция возвращает значение без уничтожения локальных переменных, кроме того, при каждом последующем вызове функция начинает своё выполнение с оператора yield.        
            --- В первый запуск вашей функции, она будет исполняться от начала до того момента, когда она наткнётся на yield — тогда она вернёт первое значение из цикла. На каждый следующий вызов будет происходить ещё одна итерация написанного вами цикла, возвращаться будет следующее значение — и так пока значения не кончатся.
            --- Генератор считается пустым, как только при исполнении кода функции не встречается yield. Это может случиться из-за конца цикла, или же если не выполняется какое-то из условий «if/else».
        
        - Yield – ключевое слово, которое используется вместо return. С его помощью функция возвращает значение без уничтожения локальных переменных, кроме того, при каждом последующем вызове функция начинает своё выполнение с оператора yield.
        - Когда программа доходит до yield, то функция переходит в состояние ожидания и продолжает работу с того же места при повторном вызове.

    Функция, содержащая yield в Python 3, называется генератором.
        - Генератор это итерируемый объект, но прочитать можно один раз. Это связано с тем, что они не хранят значения в памяти, а генеруриет их на лету.
        - Итератор — это объект, позволяющий «обходить» элементы последовательностей.


        Тип полученного значения при вызове функции – это генератор. Один из способов получения значений из генератора – это их перебрать в цикле for.

    Итератор    
        mylist = [x*x for x in range(3)] - это по сути создание списка.
        for i in mylist :
            print(i)

    Генератор
        mygenerator = (x*x for x in range(3)) - а это по аналогии с созданием списка - создание итератора (различие в круглых скобках)
        for i in mygenerator :
            print(i)

        а можно и так:
        print(next(out)) - но если вызвать больше чем в генераторе значений, то будет выбрашено исключение StopIteration

        Всё то же самое, разве что используются круглые скобки вместо квадратных. НО: нельзя применить конструкцию for i in mygenerator второй раз, так как генератор может быть использован только единожды: он вычисляет 0, потом забывает про него и вычисляет 1, завершаяя вычислением 4 — одно за другим.

    Каждый объект имеет встроенный метод __next__, который и обеспечивает обход элементов в цикле. Функция next() просто вызывает __next__.


    Для сравления:
        class AP:
            def __init__(self, a1, d, size):
                self.ele = a1
                self.diff = d
                self.len = size
                self.count = 0

            def __iter__(self):
                return self

            def __next__(self):
                if self.count >= self.len:
                    raise StopIteration
                elif self.count == 0:
                    self.count += 1
                    return self.ele
                else:
                    self.count += 1
                    self.ele += self.diff
                    return self.ele

            for ele in AP(1, 2, 10):
                print(ele)

    И------------------------
        def AP(a1, d, size):
            count = 1
            while count <= size:
                yield a1
                a1 += d
                count += 1

        for ele in AP(1, 2, 10):
            print(ele)




Строки:
    Строки Unicode:
        s = u'SomeString'
        s = ru'SomeString' - необрабатываемая строка. Так же и с R

        Для перевода из одной кодировки в Unicode используется метод unicode(). Пример s = unicode("Привет", "KOI8-R").
        Метод encode() позволяет преобразовать строки в Unicode в обычные строки в указанной кодировке. Пример: s.encode("KOI8-R")

        len(s)


List:
    Списки - это изменяемые объекты.
        a = [1, 2, 3, 4]
        a[0:2] = [5, 6] - замена, с нулевого до второго(исключительно). Даст [5, 6, 3, 4] - а можно и больше вставить, чем удаляем.
        a[0:2] = [] - удаление, с нулевого до второго. Даст [3, 4]
        a[1:1] = [6, 7] - вставка (вставит между нулевым и первым). Даст [3, 6, 7, 4]
        a[:1] = a - вставка, все что до 3го удалит и вставит содержимое a

        len(a)

Множественное присвоение.
    a, b = 1, 2

Распаковка:
    t = (1, 2, 3)
    a, b, c = t #Распаковка требует, чтоб слева стояло столько же элементов сколько в кортеже.


For:
    for i in a:
        ....

    range() - генерирует список. Его можно менять. И он есть помять.
    xrange() - генерирует псевдо список. Мы не можем менять что получили через xrange.

    else - выполняется, когда цикл (while/for) заканчивается в обычном/нормальном режиме. Если срабатывает break - то else не выполняется.

Функции:
    Определение фунции, вводит имя этой функции в текущую таблицу имен. Значение имени функции имеет тип, распознаваемый интрпретатором как определенная пользователем функция, это значени может быть привоено другому имени.

    При вызове функции другой функцией, создается так же новая таблица имен.

    При рекурсивном вызове создается собственное локальное пространство имен для каждого вызова.


    Значения по умолчанию, вычисляются один раз, только в месте определения фунцкции.
        i = [1, 2, 3]
        def func2(arg = i):
            length = len(arg)
            arg[length:] = [4, 5]
            print "arg =====", arg

        func2()
        i = [100, 200, 300]
        func2() # [1, 2, 3, 4, 5, 4, 5]

    Произвольное число аргументов:
        В этом случае значения передаются в виде кортежа.

        def func3(param, *args):
            for ii in args:
                print ii

        func3(1, 2, 3, 4)

    Именованные переменные:
        Именованные переменные всегда указываются после неименованных.

        def func4(formal, *position, **maned):
            print "formal =====", formal
            for i in position:
                print "position =====", i
            for kw in maned.keys():
                print kw, "=====", maned[kw]

Ввод/вывод:
    str() - переводит в строковое представление.
    repr() - тождественно ``

    str().rgust(3) / ljust() / center()
    print '%2d %3d %4d' % (x, x*x, x*x*x)

    f = open('/tnp/workfile', 'wb') # w - только для записи, r - только для чтения, a - для дописывания в конец, r+ для чтения и записи.


Stepik

        Операции
            Целочисленное деление // (т.е. без дробной части)
            Остаток от деления %
            Возведение в степень **

        Вечественные числа
            Записываются через точку.
            Вещественное деление через /
            5e-1 = 0.5