Коллекции:
https://habr.com/ru/post/237043/

Хэширование -это процесс преобразования объекта в целочисленную форму, выполняется с помощью метода hashCode().

MAP
	Hashtable 	- не позволяет использовать null. Ни в качестве ключа ни в качестве значения. 
					Является синхронизированной (почти все методы помечены как synchronized)
					Не рекамендуется к использованию как Vector

	HashMap 	— коллекция является альтернативой Hashtable. Позволяет использовать null в качестве ключа и в качестве значения.
					Положение не детерменировано (определяется в зависимости от hash)
					Не является синхранизированной.

	LinkedHashMap — это упорядоченная реализация хэш-таблицы. Здесь, в отличии от HashMap, порядок итерирования равен порядку добавления элементов. Данная особенность достигается благодаря двунаправленным связям между элементами (аналогично LinkedList). 

	TreeMap 	— реализация Map основанная на красно-чёрных деревьях. Как и LinkedHashMap является упорядоченной.
					По-умолчанию, коллекция сортируется по ключам с использованием принципа "natural ordering", но это поведение может быть настроено под конкретную задачу при помощи объекта Comparator, который указывается в качестве параметра при создании объекта TreeMap.


Collection

	LIST		Реализации этого интерфейса представляют собой упорядоченные коллекции.

		Vector		- Реализация динамического массива объектов. Позволяет хранить любые данные, включая null в качестве элемента.
						Не рекамендован к использованию.

		Stack 		— Данная коллекция является расширением коллекции Vector. Была добавлена в Java 1.0 как реализация стека LIFO (last-in-first-out). Является частично синхронизированной коллекцией (кроме метода добавления push())
						После добавления в Java 1.6 интерфейса Deque, рекомендуется использовать именно реализации этого интерфейса, например ArrayDeque.

		ArrayList 	— как и Vector является реализацией динамического массива объектов. Позволяет хранить любые данные, включая null в качестве элемента.

		LinkedList	— ещё одна реализация List. Позволяет хранить любые данные, включая null. Особенностью реализации данной коллекции является то, что в её основе лежит двунаправленный связный список (каждый элемент имеет ссылку на предыдущий и следующий).

	SET
		HashSet 	— реализация интерфейса Set, базирующаяся на HashMap. Внутри использует объект HashMap для хранения данных. 
						В качестве ключа используется добавляемый элемент, а в качестве значения — объект-пустышка (new Object()). Из-за особенностей реализации порядок элементов не гарантируется при добавлении.
	
	Queue		Этот интерфейс описывает коллекции с предопределённым способом вставки и извлечения элементов, а именно — очереди FIFO (first-in-first-out)
		
		PriorityQueue — является единственной прямой реализацией интерфейса Queue, не считая класса LinkedList, который так же реализует этот интерфейс.
						Данная коллекция не поддерживает null в качестве элементов.
					По-умолчанию, элементы сортируются с использованием «natural ordering», но это поведение может быть переопределено при помощи объекта Comparator, который задаётся при создании очереди. 
					Данная коллекция не поддерживает null в качестве элементов.

		ArrayDeque 	— реализация интерфейса Deque, который расширяет интерфейс Queue методами, позволяющими реализовать конструкцию вида LIFO (last-in-first-out).
					Позволяет null в качестве элементов


https://javarush.ru/groups/posts/2308-korotko-o-glavnom---java-collections-framework
https://habr.com/ru/post/128017/
https://habr.com/ru/post/421179/
https://javahelp.online/collections/rabota-s-kollektsiyami-na-java


Полиморфизм:
	Полиморфизм – это способность программы идентично использовать объекты с одинаковым интерфейсом без информации о конкретном типе этого объекта.
			Позволяет объединять объекты с общим типом или поведением в одну коллекцию или масси

	Полиморфизм
		Полиморфи́зм — возможность объектов с одинаковой спецификацией иметь различную реализацию. 

Наследование
	Наследование — Позволяет описть новый класс на основе уже существующего (родительского), при этом свойства и функциональность родительского класса заимствуются новым классом. 

Инкапсуляция
	Включение кода и данных. Скрытие реализации - работа только с интерфейсом (т.е. с публичными методами и данными)


Базы данных:
	Выписать основные методы.
	select * from TABLE where FIELD;
	select * from TABLE_1 as alias_1 join TABLE_2 as alieas_2 on (alias_1.field ....) where ....

	INSERT INTO films (code, title, did, date_prod, kind) VALUES
		('B6717', 'Tampopo', 110, '1985-02-10', 'Comedy'),
		('HG120', 'The Dinner Game', 140, DEFAULT, 'Comedy');

	UPDATE weather SET temp_lo = temp_lo+1, temp_hi = temp_lo+15, prcp = DEFAULT
		WHERE city = 'San Francisco' AND date = '2003-07-03';

	(запрос1 union запрос2) union запрос3


Погонять селекторы css/XPath

Погонять Selenium
	Основные методы.


https://unetway.com/tutorial/selenium-commands
https://kreisfahrer.gitbooks.io/selenium-webdriver/content/webdriver_intro/osnovnie_metodi_selenium_webdriver_api.html