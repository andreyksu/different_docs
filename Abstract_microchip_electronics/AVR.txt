--------------------------------------------------------------------------------

RAM:

	32 -	[0x00-0x1f] 	регистра общего назначения 
					(R0-R15) - ущербные регистры, работают не все команды. 
					(R16-R31) - полноценные регистры.
					(R26-R31) это регистры X,Y,Z   | ---> SBCI, SUBI, CPI, ANDI, ORI, LDI
			
				LD, LDS,LDD 	- загрузка  	(LDS R16,0x01)
				STS, STD	- чтение	(STS var,R16)- чтение из R16 в мфк
				Для регистров 0x00-0x1f доступны команды SBI,CBI - изменение битов этих регистров. SBIS и SBIC - проверка этих битов.			
	
	64 -	[0x20-0x5f] 	регистров в/в, это порты. Через порты производится конфигурация, всего что есть на борту контроллера
				[0x00-0x3f] - это внутренняя адресация, пространство адресов в/в. Здесь работают команды OUT/IN. 
							!NB - на два байта данные команды короче, так как не нужно хранить 2х байтные адреса.
				[0x20-0x5f] - в адресном пространстве RAM - работают команды LOAD/STORE (LD**/ST**)
			
			Все регистры по 8 бит (8ми разрадные).			
			Память данных RAM так же по 8 бит.
			Память кода как правило измеряется в словах(команд/инструкций) а они по 16разрядов (т.е. команды по 16 бит)
						
	128 -	[0x60-0xdf] 	область RAM
		
 	С ячейками ОЗУ на прямую ничего невозможно делать, с ними работа ведется через РОН (с 16го по 31ый регистр). Загружаем в регистр из памяти, поработали, загрузили обратно в память.
				
	Три рег. общего назнач в/в GPIOR 0,1,2

EEPROM и FlASH отличаются тем, что у EEPROM можно обратиться к любой произвольной ячейке, а FLASH позволяет обращаться к целоым блокам.
	
FLASH:				
		При работе с данными в рамках Flash нунжо помнить, что данные у нас лежат побайтово и контроллер при обращении к ним адресует их тоже побайтово. Адрес в словах меньше в два раза чем адрес в байтах (так как каждая команда занимает по 2 байта) и это надо учитывать при работе с данными, умножая адрес на два.
				LDI 	ZL,low(data*2) 	; заносим младший байт адреса, в регистровую пару Z
				LDI  	ZH,high(data*2)	; заносим старший байт адреса, в регистровую пару Z
							; умножение на два тут из-за того, что адрес указан в
							; в двубайтных словах, а нам надо в байтах. 
							; Поэтому и умножаем на два
							; После загрузки адреса можно загружать число из памяти
 
				LPM 	R16, Z	 	; в регистре R16 после этой команды будет число 12,
							; взятое из памяти программ.
  
							; где то в конце программы, но в сегменте .CSEG
				data: 	.db	12,34,45,23
							.db массив байтов.
							.dw массив слов — два байта.
							.dd массив двойных слов — четыре байта
							.dq массив четверных слов — восем байт.

EEPROM:
		Тут действуют те же директивы что и в flash — db, dw, dd, dq.
		EEDR - обычный восьмибитный в котором находится результат при чтении из памяти или в который заносится значение при записи в EEPROM
		EEARH и EEARL - регистры для адресации места записи/чтения
		EECR - управляющий регистр.
			бит EERIE [3] - EEPROM Ready Interrupt Enable или разрешение прерывания при обнулении бита EEWE (что происходит после окончания записи).
			бит EEMWE [2] - EEPROM Master Write Enable - необходимо установить этот бит в "1" и в течении 4х тактов дать команду на запись - установив бит EEWE в "1". Этот бит аппаратно сбрасывается в "0" после 4 тактов.
			бит EEWE [1] - EEPROM Write Enable - бит, разрешающий запись в память (при условии, что бит EEMWE установлен).
			бит EERE [0] - EEPROM Read Enable - при установке соответствующего адреса ячейки, которую будем считывать, данный бит запускает процесс чтения.
			
			.include "m8def.inc"
				.def    wreg    =R16
				ldi      wreg, 0b10100000
				out    MCUCR, wreg
				ldi wreg, 0x00
			main:
				out   EEARL, wreg        ; запись адреса, есть еще EEARH
				out   EEDR, wreg          ; данные
				sbi    EECR, EEMWE
				sbi    EECR, EEWE
				sbic  EECR, EEWE        ; проверка окончания записи
				rjmp PC-1
				inc    wreg                  ; инкрементируем регистр
				cpi    wreg, 0x05        ; сравниваем значение с константой 0x05
				breq PC+2                  ; перепрыгиваем через след. команду
				; если равенство выполняется т.е. wreg = 0x05
			rjmp    main
				sleep
				------------------Второй пример------
				EEPROM_WR:           ;EEPROM Write Sub-Routine
					sbic  EECR, EEWE   	;If EEWE Not Clear
					rjmp  EEPROM_WR    	;Wait Longer
				SPM_BUSY:            		;(Omit if Self-Programming is Not Used)
					sbic  SPMCR, SPMEN 	;If SPMEN Not Clear
					rjmp  SPM_BUSY     	;Wait Longer
					out   EEARH, r16   	;Output Address Byte (High)
					out   EEARL, r17   	;Output Address Byte (Low)
					out   EEDR, r18    	;Output Data Byte
					cli                	;Disable Global Interrupts
					sbi   EECR, EEMWE  	;Set Master Write Enable
					sbi   EECR, EEWE   	;Set EEPROM Write Strobe
								;This instruction takes four clock
								;cycles.
					sei                	;Enable Global Interrupts
					ret			;Return From Sub-Routine	
				
				------------------Третий пример------	
					        //запись в память:

				LDI R16, 0 ; Загружаем адрес нулевой ячейки
				LDI R17, 0 ; EEPROM
				LDI R21, 45 ; и хотим записать в нее число 45
				RCALL EEWrite ; вызываем процедуру записи.

				//чтение:
				LDI R16,0 ; Загружаем адрес нулевой ячейки
				LDI R17,0 ; EEPROM из которой хотим прочитать байт
				RCALL EERead ; вызываем процедуру чтения. После которой
				; в R21 будет считанный байт.

			 

			    EEWrite: ; процедуры записи
				SBIC EECR,EEWE ; Ждем готовности памяти к записи. Крутимся в цикле
				RJMP EEWrite ; до тех пор пока не очистится флаг EEWE

				CLI ; Затем запрещаем прерывания.
				OUT EEARL, R16 ; Загружаем адрес нужной ячейки
				OUT EEARH, R17 ; старший и младший байт адреса
				OUT EEDR, R21 ; и сами данные, которые нам нужно загрузить

				SBI EECR, EEMWE ; взводим предохранитель
				SBI EECR, EEWE ; записываем байт

				SEI ; разрешаем прерывания
				RET ; возврат из процедуры

			    EERead: ; процедуры чтения
				SBIC EECR,EEWE ; Ждем пока будет завершена прошлая запись.
				RJMP EERead ; также крутимся в цикле.
				OUT EEARL, R16 ; загружаем адрес нужной ячейки
				OUT EEARH, R17 ; его старшие и младшие байты
				SBI EECR, EERE ; Выставляем бит чтения
				IN R21, EEDR ; Забираем из регистра данных результат
				RET	



Макроассемблер:
		.include позволяет подключать в тело твоей программы кусок кода из другого текстового файла.
		
		.def позволяет привязать к любому слову любое значение из ресурсов контроллера — порт или регистр.
			.def 	schetchik = R0
			.def 	pomoika = R16
			
		.undef после которого компилятор напрочь забывает, что данной переменной что либо соответствовало.
			.undef 	pomoika
			
		 .equ это присвоение выражения или константы какой либо символической метке.
		 	.equ 	Time = 5
			.equ 	Acсelerate = 4
			.equ 	Half_Speed = (Accelerate*Time)/2	
			
		Как и все JMP - операторы перехода, копируют в PC адрес что у JMP в аргументе. JMP для Atmega8 не определен, так как за два прыжка мжно справиться RJMP. RJMP - ограничен числом/размером прыжка (63 адреса?)
		RJMP - относительный переход 	(RJMP PC+2) - прыгаем на 2 вперед от тек. пложения
		IJMP - косвенный переход (через X,Y,Z)
				.CSEG		; Кодовый сегмент
			NOP
 				.ORG 0x0010
			M1:		NOP
					NOP
					LDI	ZL,low(M2)	; Загрузили в индекс 
					LDI	ZH,High(M2)
 					IJMP
 					NOP
				
			M2:		NOP
					RJMP M1
					NOP
		CPI(CP) - сравнивает Регистр и константу. Сами рег. не меняет а меняются лишь вфлаги H,S,V,N,Z
			CP	reg1,	reg2
			CPI	hreg,	number
					
Стек:		Сколько положил в стек, столько и достань!!!! Золотое правило
		CALL (ICALL, RCALL, CALL) 	группа команд перехода к подпрограмме 
		RET - И команда возврата из подпрограммы 	
		RCALL - впихивает в стек адрес следующей, а команда RET достает из стека адрес этой команды, и прыгает по этому адресу		
		RET	- данная команда берет из стека два последних байта и помещает в PC и соответственно происходит переход, по адресу, что лежал в стеке. По этому важно иметь в стеке правильный адрес а не кашу.
		
Прерывания:	   	
		* Вектор прерывания + обработчик. 
			.ORG в векторе прерывания используется для точечного размещения метки обработчика прирывания, так как именно по указанному адресу прыгает контроллер при возникновении этого вида прерывания.
		* Когда возникате прерывания, запрещается глобальное прерывание. После окончания, обработки прерывания, разрешается глобальное прерывание.
		* Если во момент обработки прерывания придут др. прерывания, то флаги будут выставлены, и когда окончится обрабатыватья тек. прерывание, начнут выполняться те у которыг флаги подняты. Потяреются только однотипные прерывания, так как флаг то один.
		* Перед работой с прерываниями нужно обязательно инициализировать стек, лишь после этого разрешать прерывания, ибо при возникновении прерывания, значение PC записывается в стек.
		* При обработке прерывания, нужно сделать быстро дело и выйти из прерывания (т.е. что то вытащили из потров, сложили в ОЗУ и вышли из прерывания), а потом в фоне можно обработать данные.
		* Перед работой в прерывании, нужно все ячейки сохранить в стек в том числе значение регистра SREG, а лишь потом приступать к работе. Перед возвратом, верунть все в регистры и выйти из прерывания.
		
		Еще раз:
			Когда возникает прерывание, то PC записывается в Стек. В PC записывается адрес прерывания. Контроллер приходит по этому адресу - и как правило по этому адресу соит rjmp на нужный обработчик прерывания. После окончания прерывания из Стека достается адрес (адрес программы от куда ушли при возникновении прерывания) и запихивается в PC.

		Вектор прерывания, это по сути метки находящиеся на нужном месте куда приходит МК при возникновении прерывания. У каждого свой адрес.
		
SREG:			
			I — флаг разрешения прерываний. Когда установлен в 1 — прерывания разрешены. 
			T — пользовательский флаг. Можно юзать по своему назначению. (BLD Rn,bit и BST Rn,bit)
			H — флаг полупереноса. Это если произошел заем бита из старшей половины байта в младшую. То есть когда из числа 0001 0111 пытаются вычести 0000 1000, то происходит заем бита из более старшего разряда, так как младшая тетрада уменьшаемого меньше чем младшей тетрады вычитаемого.
			S — флаг знака. 1 — значит минус. При вычислении чисел со знаком он возникает если после арифметической операции возник отрицательный результат. Флаг S = V XOR N. 
			V — Флаг переполнения дополнительного кода. Это если мы считаем число в дополнительном коде со знаком и оно вылезло за пределы регистра.
			N — флаг отрицательного значения. Если в результате арифметической операции 7 бит результата стал 1, то этот флаг тоже станет 1. 
			Z — флаг нуля. Если в результате какой либо операции получился ноль, то вылазит этот флаг. Чертовски удобно для всех целей! 
			С — флаг переноса. Если в результате операции произошел выход за границы байта, то выставляется этот флаг. Вообще самый юзаемый флаг после Z и I.
			
			SE* для установки и CL* для сброса. Вместо звездочки подставляется нужный флаг, например, CLI — запрет прерываний. 
			Команда INC прибавляет к регистру 1, но несмотря на то, что она может добить регистр до переполнения, флаг переполнения С она не ставит. 
		BR** - дальнобойность составляет 63 команды (BRCS, BRCC итд)

Test & Skip:
		Работает она по принципу “Проверяем условие, если справедливо — пропускаем следующую команду”
		Запомнить просто, первая буква это Skip — пропуск. Вторая условие — С=Clear, т.е. 0 S=Set, т.е. 1. Соответственно S**C пропуск если сброшено. S**S пропуск если установлено.
		Команды SBRC/SBRS
				SBRC 	R16,3	; Если бит 3 в регистре R16 = 0, то прыжок через команду, на NOP 
				RJMP	bit_3_of_R16_Not_Zer0
				NOP 
 
				SBRS 	R16,3	; Если бит 3 в регистре R16 = 1, то прыжок через команду, на NOP 
				RJMP	bit_3_of_R16_Zer0	 
				NOP

		SBIC/SBIS -Аналогичные команды но проверяет она не биты регистров РОН, а биты регистров периферийных устройств. Те самые,что идут в памяти между блоком РОН и оперативкой. Но есть у ней ограничение — она может проверить только первые 1F регистров ввода вывода.	
			Для првоерки больше 1F
				IN	R16, UCSRC	; Хватаем байт из регистра, целиком.
				ANDI	R16,1<<3	; Накладываем на него маску 00001000
				; В результате, все байты кроме третьего Обнулятся. А третий каким был таким и останется. Был нулем - будет нуль и будет Z Не был нулем, не будет Z флага. =))))
 
				BREQ	Bit_3_of_R16_Equal_Zero



Остановился на (AVR. Учебный курс. Ветвления на индексных переходах) - родительская страница http://easyelectronics.ru/category/avr-uchebnyj-kurs/page/4 идти снизу вверх

---------------
Ревич:
	* Большенство команд выполняются за один такт кроме команд (ветвления, обращения к памяти, и команды оперирующие данными большой длины)
	* Двухступенчатый конвейер - в одном такте, одна команда выполняется, другая выбирается.
	* Область программы и область памяти разделены (Грвардская архитектура)


	Flash
		Имеет страничную организацию (размер страницы зависит от модели от 64 до 256 байт).
			Страница программируется только целиком.
			Слово - по два байта каждое (т.к. каждая команда занимает по два байта) - кроме отдельных JMP, CALL
				Т.е. счетчик команд сдвигается при выполнении очередной команды на два байта (одно слово)

		FLASHEND - константа. Последний адрес flash - т.е. размер.

		В начале как правило распологается таблица векторов прерываний. Псле нее идет уже программа. Если таблица есть, то первой идет вектор сброса RESET.
			- Однако если таблицы прерываний нет то основная программа может начинаться с $0000
			- В последних адресах может располагаться загрузчик (загрузчик программы - допустим те же Arduino) - но тогда в самаом начале идет адрес загрузчика. А вектор прерывания смещен.

		В листинге assembler начало работы с FlASH отмечается как .CSEG
			.CSEG			; Кодовый сегмент

		Именно в Flash и есть условные и безусловные переходы. RJMP и JMP соответственно.
			RJMP - записывает с PC смещение:
				M2:	RJMP PC + 2
					RJMP PC - 6
					RJMP M2	;перейдет на М2

				А можно
					LDI 	ZL, low(M2) 	;Т.к. адрес в Flash 2х байтный а регистры 1байтные. 
											;Берем Z регистр, что может состоять из 2х байт и запихиваем в его части адреса. Можно использвать три регистра для адресации X, Y, Z
					LDI 	ZH, High(M2)
					IJMP	


			JMP - уходит по прямому указанию
				JMP 0x000001	- занимает 4 байта (сама команда + адрес перехода)

		.ORG - может перетащить код на указанный адрес
			.ORG 0x0010
				Это полезно когда требуется перешагнуть таблицу прерываний. Или для записи бутлоадера.



	SRAM
		* Адресация в отличии от Flash идет побайтно а не пословно.
		* Отсутствуют каки либо страницы, сегменты или банки - т.е. память линейная.
			Размер колеблится до 4-8Кбайт.

		$0000-$001F - 	R0-R31 ригистра общего назначения
		$0090-005F	-	64 РВВ регистра ввода/вывода
		$0060-$FFFF - 	сама SRAM - разумеется ограничиватется моделью
			При этом РОН и РВВ не отнимают место у SRAM - если МК имеет 512байт то пространство будет $0060-$025F

	EPROM
		* Окончание обозначается константой EEPROMEND.
		* Память тоже не является страничой или сегментами. Т.е. память обычная побайтовая.
			* Правда  поздних версиях добавлена поддержка страниц в 4байта.

		* Чтение за один машинный такт (по факту за 4ре под капотом но для разработчика за 1такт)
		* Запись ~2-4мс - за это время контроллер выполняет тысячи операций (и тут важно следить за прерыванием, если кто-то вклинится по прерыванию).

		Вообще запись в EPROM в программе не должа идти (т.к. возможна порча см. Ревич EEPROM) - запись констант в EEPROM должна идти при программировании контроллера.


	RESET
		Установка начального режима работы МК.
			РВВ - устанавливаются в дефолтное положение т.е. в 0
			РОН - в произвольное, по этой причине нужно задавать значение самостоятельно.
			Программа после сброса начинает выполняться с $0000

		Сброс происходит при включении питания. Или подачи низкого напряжения на вывод Reset(инверсия по факту высокий). Или оконачание отсчета сторожевого таймера.
		MCUCSR - регистр в котором хранится информация, от какого источника был выполнин предыдущий сброс.


	Переферия:
		Все переферийные устройства адресуются через РВВ. Но работа ведется через РОН

		Порты IO являются параллельными.
		Порты являются 8-разрадными.
		Выводы ног как правило соотносятся с поратами и являются двунаправленными ввод-вывод. Однак эти же ноги могу быть скофирурированны и для целевых нужд UART (PD0-PD1)/АЦП (А-порт).
			При этом если используется АЦП - то остальные ноги порта А - как правило не используют(даже если они в АЦП не учавствуют), дабы избежать помех.

		Порты являются автономными друг от друга.
			При включении все усатройства отключены, а порты работаню тна вход (с высоким импедансом - высокое входное сопротивление).

			Для установки:
				* Направления используется регистра DDRx (DDRA) - где на соответствующей ноге установка бита в 1 это вывод, 0 - ввод
			 	* Состояния используется регистр данных PORTx - все что будет записано в этот геристр автоматом отобразится на ноге (разумеется если сконфигурирован порт на вывод)
			 		Если порт сконфигурирован на вход - то выставление 0 или 1 в PORTx имеет др. смысл.
			 			0 - по умолчанию. Вход с высоким сопротивлением.
			 			1 - подтягивающий резистор pull-up. 35-120kO. Если используется с кнокой на землю или для общей шины, то его не хватает и добавляют параллельный рехистор от 1-5кОм

			Чтение данных с порта идет через PINx (важно не через PORTx)
				PINx - это не регистр. Это массив, что позволяет считать данны с порта.

	Счетчики:
		Работают от частоты процессора или поделенной на 8,64,256,1024. Или внешнего источника.

		Таймер-счетчик имеет три регистра:
			- счетый регистр TCNT0
				- При каждом такте увеличивается на 1 (если настроен на каждый такт МК ну или на каждый 8ой такт увеличивается на 1)
				- Когда счетчик работает, записывает в него не рекамендуется, так как схема сравнения блокируется на 1 такт.
				- Запись в регистр 
					CLI
					OUT TCNT0,Rx
					SEI
				- Тикает раз при досчете предделителя до выставленного значения. Т.е. допустим выставлено 64 соответственно как только предделитель досчитает до 64 этот таймер тикнет.
			- регистр сравнения OCR0
				- Значение этого регистра постоянно сравнивается со счетным регистром. И при совпадении можно что то выполнять (вызвать пререывание, менять состояние вывода OC0)
			- конфигурационные регистр TCCR0


			И три регистра относящихся ко всем таймерам
				- конфигурационный регистр TIMSK
					- содержит флаги разрешения прерываний (при переполнении или при совпадении с OCR0)
						- Разумеется для этого должно быть разрешены глобальные прерывания в регистре SREG бит I
				- статусный регистр TIFR.
					- устанавливается в 1 (при переполнении или совпадении с OCR0 соответственно)
				- регистр специальных функций SFIOR

		Перед установкой предделителя - его нужно сбрасывать.
			Это делается для точного понимания когда начинаем считать (т.е. предделитель работает все время, вне зависимости от настроек таймера).
				Допустим есть предделитель на 1024 и когда он сработает первый раз не известно. Может он уже досчитал 1000, и соответственно сработает сразу же.
			Но предделитель один на все таймеры - это нужно учитывать
				Сбрасывая предделитель, для др. таймеров, тоже будет сброс и они начнут считать снова, а тик для таймера так и не произойдет.

			Для сброса предделителя нужно записать бит PSR10 в регистр SFIOR


		Прерывания
			Для работы прерывания от таймера нужно разрешить прерывания вообще SREG.
				Кроме непосредственного установления флага можно использовать команды sei(разрешить)/cli(Запретить)

			Кроме общего прерывания для каждой перефериии есть свое разрешение/запрещение:
				Для таймера 
					TIMSK/ETIMSK
				Для внешний
					GIMSK GIGR

			При возникновении прерывания, флаг I сбрасывается - запрещая обработку остальных прерываний.
				- Когда обработка закончится, флаг вернется по команде reti.
				- Когда нужно прерывания допустить при обработке текущего т.е. вложенные прерывания, то можно вручную разрешить через sei.

				После сборса флага I контроллер определят от кого произошло прерывание
					Для таймера это TIFR/ETIFR
					Для внешних прерываний GIFR/EIFR

				При этом перед началом работы - эти флаги необходимо очистить.
					ldi temp,$FF
					out GIFR,temp ;сбросить флаги внешних прерываний
					out TIFR,temp ;сбросить флаги прерываний таймеров

			После определения типа прерывания, контроллер автоматически определяет адрес вектора прерываний.
				Перед переходом в вектор прерываний, происходит сохранения PC в стеке.
				Сбрасываются флаги.


			Ставят сразу после метки на кторую осуществляется переход по вектору сбора RESET
				ldi temp,low(RAMEND) ;загрузка указателя стека
				out SPL,temp
				ldi temp,high(RAMEND) ;загрузка указателя стека
				out SPH,temp
				. . . . . ;другие установки
				sei ;разрешаем прерывания


			Окончание процедуры обработки прерывания должно быть командой reti. По этой команде восстанавливается содержимое считчика команд и восстанавливается флаг разрашения прерываний.

			Прерывания обрабатываются в том порядке, в котором они расположены в векторе-прерываний.